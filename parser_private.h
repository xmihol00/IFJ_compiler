
#ifndef __PARSER_PRIVATE_H__
#define __PARSER_PRIVATE_H__

//=========================================================================================================
// File:        parser_private.h
// Case:        VUT, FIT, IFJ, compiler project
// Date:        9. 12. 2020
// Author(s):   David Mihola
// Contac(s):   xmihol00@stud.fit.vutbr.cz
// Compiled:    gcc version 9.3.0 (Ubuntu 9.3.0-17ubuntu1~20.04)
// Description: Header file containing private constant and function declarations for the parser module.
//==========================================================================================================

#include "parser.h"

enum states {
    INITIAL = 0,
    MAIN_PCKG_NEXT = 1,
    NL_NEXT_GLOBAL = 2,
    FUNCTION_NEXT = 3,
    FUNCTION_NAME = 4,
    FUNC_PARAM_FIRST = 5,
    FUNC_PARAM_NAME = 6,
    FUNC_PARAM_TYPE = 7,
    FUNC_COMMA_END = 8,
    FUNC_RET_TYPE = 9,
    RET_TYPE_OB = 10,
    RET_TYPE_COMMA = 11,
    MUL_RET_TYPES = 12,
    NAMED_RET_TYPES = 13,
    NRET_TYPE_COMMA = 14,
    RET_NAME = 15,
    OCB_NEXT = 16,
    STATEMENT = 17,
    STATEMENT_ELSE = 18,
    STATEMENT_ELIF = 19,
    NL_NEXT = 20,
    ASSIGN = 21,
    MULTI_ASSIGN = 22,
    MUTLI_ASSIGN_COMMA = 23,
    PSA = 24,
    FOR1 = 25,
    FOR1_ASSGN = 26,
    FOR1_MULTI_ASSGN = 27,
    FOR1_MA_COMMA = 28,
    FOR3 = 29,
    FOR3_ASSGN = 30,
    FOR3_MULTI_ASSGN = 31,
    FOR3_MA_COMMA = 32,
};

/****************************************** PARSER DESIGN ********************************************
 * 
 * Description: Automat, which parses the source code to a special internal token code. 
 *              Saves information about all defined functions and variables to the symtable.
 * 
 * Design: Matrix of functions with the sizes of an interval representing the return values of 
 *         function scanner() and the current parser state. Each function then processes only 
 *         one type of lexem. While processing the lexem generated by scanner, tokens can be 
 *         added in front/after/instead of the lexem, everything is saved to the token linked list. 
 *         The called function then sets the next state (usually based also on some other data, 
 *         like the curly bracket stack).
 * 
 * States and transition:
 * INITIAL: 
 *     package keyword -> MAIN_PCKG_NEXT
 *     new line -> INITIAL
 * 
 * MAIN_PCKG_NEXT:
 *     main -> NL_NEXT_GLOBAL
 * 
 * NL_NEXT_GLOBAL:
 *     new line -> FUNCTION_NEXT
 * 
 * FUNCTION_NEXT:
 *     func -> FUNCTION_NAME.
 *     new line -> FUNCTION_NEXT
 * 
 * FUNCTION_NAME: 
 *     Function identifier -> FUNC_PARAM_NAME, create function entry in the symtab.
 * 
 * FUNC_PARAM_FIRST:
 *     Function parameter identifier -> FUNC_PARAM_TYPE, add the parameter name to the currently open 
 *     function entry in symtab,
 *     close bracket -> FUNC_RET_TYPE,
 *     new line -> FUNC_PARAM_FIRST (each parameter can be on a separate line)     
 * 
 * FUNC_PARAM_NAME: 
 *     Function parameter identifier -> FUNC_PARAM_TYPE, add the parameter name to the currently open 
 *     function entry in symtab,
 *     new line -> FUNC_PARAM_NAME (each parameter can be on a separate line)
 * 
 * FUNC_PARAM_TYPE: 
 *     parameter type keyword -> FUNC_COMMA_END.
 * 
 * FUNC_COMMA_END: 
 *     comma -> FUNC_PARAM_NAME
 *     closed bracket -> FUNC_RET_TYPE or syntax error if the last token was comma
 * 
 * FUNC_RET_TYPE: 
 *     string, int, float, bool -> OCB_NEXT, add the return type to the currently open function entry in the symtab.
 *     open curly bracket -> STATEMENT, push FUNCTION_CB to curly bracket type stack.
 *     open bracket -> RET_TYPE_OB.
 * 
 * RET_TYPE_OB:
 *     type -> RET_TYPE_COMMA,
 *     idf -> NAMED_RET_TYPES,
 *     close bracket -> OCB_NEXT,
 *     new line -> RET_TYPE_OB
 * 
 * RET_TYPE_COMMA:
 *     comma -> MUL_RET_TYPES,
 *     close bracket -> OCB_NEXT
 * 
 * MUL_RET_TYPES:
 *     type -> RET_TYPE_COMMA,
 *     new line -> MUL_RET_TYPES
 * 
 * NAMED_RET_TYPES:
 *     type -> NRET_TYPE_COMMA
 * 
 * NRET_TYPE_COMMA:
 *     comma -> RET_NAME,
 *     close bracket -> OCB_NEXT,
 *     
 * RET_NAME = 14
 *     idf -> NRET_TYPE_COMMA,
 *     new line -> RET_NAME
 * 
 * OCB_NEXT: 
 *     Open curly bracket -> STATEMENT, push FUNCTION_CB to the curly bracket stack
 * 
 * STATEMENT: 
 *     if -> PSA, set the expression type to E_IF,
 *     for -> FOR1, set the expression type to E_FOR1,
 *     return -> PSA, set the expression type to E_RETURN,
 *     variable identifier -> find the variable in the symtab, if it does not exist create a new entry, set undef_var to true. 
 *         Set the state to ASSIGN
 *     function -> PSA, push expression type E_FIRST_FUNC to the expression stack and set the expresion type 
 *         to E_PARAM. 
 *     close curly bracket -> pop the curly bracket stack if the popped expression is E_IF or E_ELIF 
 *         set the state to STATEMENT_ELSE, otherwise to NL_NEXT
 *     new line -> STATEMENT
 * 
 * STATEMENT_ELSE: 
 *     else -> STATEMENT_ELIF, set the expression type to E_ELSE,
 *     new line -> STATEMENT
 * 
 * STATEMENT_ELIF:
 *     if -> PSA, change the expression type to E_ELIF, 
 *     open curly bracket -> NL_NEXT
 * 
 * NL_NEXT:
 *     new line -> STATEMENT
 * 
 * ASSIGN: 
 *     equal (:=, =, +=, ...) -> PSA, set the expression type to E_ASSGN, store the equal type,
 *     comma -> MULTI_ASSIGN, set the expression type to E_MULTI_ASSGN
 * 
 * MULTI_ASSIGN:
 *     variable identifier -> MUTLI_ASSIGN_COMMA, find the variable in the symtab, if it does not exist, 
 *     create new one and set undef_var to true,
 *     new line -> MULTI_ASSIGN (each variable can be on a separate line)
 * 
 * MUTLI_ASSIGN_COMMA:
 *     comma -> MULTI_ASSIGN,
 *     equal (:=, =) -> PSA and store the equal type
 * 
 * PRECEDENCE SYNTAX ANALYSIS (PSA): (the precedence syntax analysis is implemented in module oRPN{.c, .h, _private.h})
 *                              oRPN stands for: optimized reverse polish notation
 *     constant -> PSA, check underflow/owerflow, in case of error raise lexical error, otherwise add
 *         the constant to the oRPN.
 *     operator -> PSA, add the operator to the oRPN.
 *     function -> PSA, add the function to the oRPN.
 *     comma -> PSA if the expression type is E_PARAM, E_RET, E_MULTI_ASSGN, E_MULTI_FOR1 or E_MULTI_FOR3,
 *         otherwise syntax error.
 *     new line -> 
 *         PSA if the last token type is T_OP, T_SEMI, T_OB, T_NL, T_EQ, T_FUNC, T_IF or T_COMMA,
 *         STATEMENT if the expression type is E_ASSGN, E_MULTI_ASSGN or E_RETURN, otherwise syntax error.
 *              If the expression type is E_ASSGN or E_MULTI_ASSGN add the previously stored equal to the oRPN. 
 *              In all cases end the precedence analysis.
 *     open curly brackets -> NL_NEXT if the expression type is E_IF, E_ELIF, E_ELSE, E_FOR3 or E_MULTI_FOR3, 
 *         otherwise syntax error. If the expression type is not E_ELSE end the precedence analysis
 *     open bracket -> PSA, add the open bracket to the oRPN.
 *     close bracket -> PSA or 
 *                      NL_NEXT if the close bracket is of a first called function, then end the precedence analysis.
 *     semicolon -> PSA if the expression type is E_FOR1 or E_MULTI_FOR1, 
 *                  FOR3 if the exression type is FOR2, otherwise syntax error. 
 *         If the expression type is E_FO1 or E_MULTI_FOR1 add the stored equal type to the oRPN. 
 *         In all cases end the precedence analysis.
 * 
 * FOR1:
 *     variable identifier -> FOR1_ASSGN,
 *     semicolon -> PSA, set the expression type to E_FOR2,
 *     new line -> FOR1
 * 
 * FOR1_ASSGN:
 *     eq -> PSA,
 *     comma -> FOR1_MULTI_ASSGN, set the expression type to E_MULTI_FOR1,
 * 
 * FOR1_MULTI_ASSGN:
 *     variable identifier -> FOR1_MA_COMMA,
 *     new line -> FOR1_MULTI_ASSGN 
 * 
 * FOR1_MA_COMMA:
 *     comma -> FOR1_MULTI_ASSGN;
 *     eq -> PSA
 * 
 * FOR3:
 *     variable identifier -> FOR3_ASSGN,
 *     OCB -> NL_NEXT,
 *     new line -> FOR3
 * 
 * FOR3_ASSGN:
 *     eq -> PSA,
 *     comma -> FOR3_MULTI_ASSGN, set the expression type to E_MULTI_FOR3,
 * 
 * FOR3_MULTI_ASSGN:
 *     variable identifier -> FOR3_MA_COMMA,
 *     new line -> FOR3_MULTI_ASSGN 
 * 
 * FOR3_MA_COMMA:
 *     comma -> FOR3_MULTI_ASSGN;
 *     eq -> PSA
 *
 ************************************* END OF PARSER DESIGN ******************************************/


typedef void (*void_func_t)(string_t data); // state transision function

bool return_check_function(uint8_t coming_token); // control of return in functions with return type

// ******************* state transition function definitions ***********************

// ================================== INITIAL ======================================

void in_nl(string_t data);

void in_pckg(string_t data);

// ============================ MAIN PACKAGE NEXT ==================================

void pckg_midf(string_t data);

void pckg_nl(string_t data);

// ========================== NEW LINE NEXT GLOBAL =================================

void nlg_nl(string_t data);

// ============================= FUNCTION NEXT =====================================

void fnn_func(string_t data);

void fnn_nl(string_t data);

// ============================= FUNCTION NAME =====================================

void fnnm_fidf(string_t data);

// ====================== FUNCTION FIRST PARAMETER NAME ============================

void fpf_idf(string_t data);

void fpf_cb(string_t data);

void fpf_nl(string_t data);

// ========================= FUNCTION PARAMETER NAME ===============================

void fprm_idf(string_t data);

void fprm_nl(string_t data);

// ========================= FUNCTION PARAMETER TYPE ===============================

void fpt_type(string_t data);

// ========================== FUNCTION COMMA OR END ================================

void fnc_cmm(string_t data);

void fnc_cb(string_t data);

// ========================== FUNCTION RETURN TYPES ================================

void fncrt_type(string_t data);

void fncrt_ob(string_t data);

void fncrt_ocb(string_t data);

// ========================== FUNCTION RETURN TYPE OB ==============================

void frtob_type(string_t data);

void frtob_idf(string_t data);

void frtob_cb(string_t data);

void frtob_nl(string_t data);

// ============================= RETURN TYPE COMMA =================================

void rtc_comm(string_t data);

void rtc_cb(string_t data);

// =========================== MULTIPLE RETURN TYPES ===============================

void mrt_type(string_t data);

void mrt_nl(string_t data);

// ======================== MULTIPLE NAMED RETURN TYPES ============================

void mnrt_type(string_t data);

// ========================= NAMED RETURN TYPES COMMA ==============================

void mnrc_comm(string_t data);

void mnrc_cb(string_t data);

// ================================ RETURN NAME ====================================

void rtn_idf(string_t data);

void rtn_nl(string_t data);

// ========================= OPEN CURTLY BRACKET NEXT ==============================

void ocbn_ocb(string_t data);

// ================================ STATEMENT =====================================

void expr_kw(string_t data);

void expr_idf(string_t data);

void expr_fidf(string_t data);

void expr_ccb(string_t data);

void expr_nl(string_t data);

// ============================= STATEMENT ELSE ===================================

void ees_kw(string_t data);

void ees_nl(string_t data);

// ============================= STATEMENT ELIF ===================================

void eel_kw(string_t data);

void eel_ocb(string_t data);

// ============================== NEW LINE NEXT ====================================

void nln_nl(string_t data);

// ============================== FIRST VARIABLE ===================================

void fv_eq(string_t data);

void fv_cmm(string_t data);

// ========================== MULTIPLE FIRST VARIABLE ==============================

void mfv_idf(string_t data);

void mfv_nl(string_t data);

// ======================= MULTIPLE FIRST VARIABLE COMMA ===========================

void mfvc_cmm(string_t data);

void mfvc_eq(string_t data);

void mfvc_defeq(string_t data);

// ======================== PRECEDENCE SYNTAX ANALYCIS =============================

void psa_op(string_t data);

void psa_cmm(string_t data);

void psa_nl(string_t data);

void psa_ocb(string_t data);

void psa_cb(string_t data);

void psa_semi(string_t data);

void psa_idf(string_t data);

void psa_fidf(string_t data);

void psa_num(string_t data);

void psa_str(string_t data);

void psa_op(string_t data);

void psa_ob(string_t data);

void psa_cb(string_t data);

void psa_ocb(string_t data);

void psa_nl(string_t data);

// ========================  CLOSE CURLY BRACKET NEXT ==============================

void ccbn_ccb(string_t data);

// ======================== FIRST PART OF FOR HEADER ===============================

void f1_id(string_t data);

void f1_semi(string_t data);

void f1_nl(string_t data);

// ============================= FOR1 ASSIGNMENT ===================================

void f1a_eq(string_t data);

void f1a_comm(string_t data);

// ========================== FOR1 MULTI ASSIGNMENT ==================================

void f1ma_id(string_t data);

void f1ma_nl(string_t data);

// ======================= FOR1 MULTI ASSIGNMENT COMMA ===============================

void f1c_comm(string_t data);

void f1c_eq(string_t data);

// ======================== THIRD PART OF FOR HEADER ===============================

void f3_id(string_t data);

void f3_ocb(string_t data);

void f3_nl(string_t data);

// ============================= FOR3 ASSIGNMENT ===================================

void f3a_eq(string_t data);

void f3a_comm(string_t data);

// ========================== FOR3 MULTI ASSIGNMENT ==================================

void f3ma_id(string_t data);

void f3ma_nl(string_t data);

// ======================= FOR3 MULTI ASSIGNMENT COMMA ===============================

void f3c_comm(string_t data);

void f3c_eq(string_t data);

// ========================== FOR CYCLE IDENTIFIER =================================

void fcv_idf(string_t data);

void fcv_ocb(string_t data);

void fcv_nl(string_t data);

void fcv_semi(string_t data);

// ================================= ERROR =========================================

void syn_err(string_t data);

#endif // __PARSER_PRIVATE_H__
