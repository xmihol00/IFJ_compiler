
#ifndef __ENUMS_H__
#define __ENUMS_H__

//=========================================================================================================
// File:        enums.h
// Case:        VUT, FIT, IFJ, compiler project
// Date:        9. 12. 2020
// Author(s):   David Mihola, Lukas Foltyn, Vladislav Sokolovskii
// Contac(s):   xmihol00@stud.fit.vutbr.cz, xfolty17@stud.fit.vutbr.cz, xsokol15@stud.fit.vutbr.cz
// Compiled:    gcc version 9.3.0 (Ubuntu 9.3.0-17ubuntu1~20.04)
// Description: Header file containing enumeration defifinitions used trough out the programm
//==========================================================================================================

#include <stdlib.h>
#include <stdio.h>
#include <stdbool.h>
#include <stdint.h>
#include <string.h>
#include <errno.h>
#include <limits.h>
#include <math.h>
#include <ctype.h>

#define EMPTY 0xff

enum errors {
    MEM_ERR = 99,
    INTERNAL_ERR = 99,
    LEXICAL_ERR = 1,
    SYNTAX_ERR = 2,
    SEMANTIC_DEF_ERR = 3, 
    SEMANTIC_DATA_TYPE_ERR = 4,
    SEMANTIC_EXPR_ERR = 5,
    SEMANTIC_PARAM_COUNT_ERR = 6,
    SEMANTIC_RET_COUNT_ERR = 6,
    SEMANTIC_OTHER_ERR = 7,
    SEMANTIC_ZERO_DIV_ERR = 9,
    };

/** 
 * @enum Tokens for lexemes (f.e. keywords), that can be stored as single unt8_t.
**/
enum token_data {
    IF = 5,         /// if
    ELSE,           /// else
    FOR,            /// for
    FUNC,           /// func
    RETURN,         /// return
    PACKAGE,        /// package
    TRUE,           /// true
    FALSE,          /// false
    NEG,            /// - (unary)       // L1
    POS,            /// + (unary)       // L1
    NOT,            /// !               // L1
    POS_NOT,        /// even times !    // L1
    OCB,            /// {
    CCB,            /// }
    SEMICOLON,      /// ;
    // both the CB and OB are added to the precedence analysis separately, however, the precedence remains
    // i.e. opening bracket has the highest precedence (no operators are evaluated on it's addition), 
    // closing bracket has the lowest precedence (all operators are evaluated on it's addition), until
    // first occurence of a matching opening bracket
    CB,             /// )
    OB,             /// (
    INT_FLOAT,      /// 0 value number value of type int or float used for negation if the variable type is not defined
    VAR,
    NONE,
    CONCAT,
    IDIV,
    ZERO,

    //an inctruction is encoded on the 3 MSB
    // L2
    MUL = 0x2e,             /// *
    DIV = 0x2f,             /// /
    // L3
    ADD = 0x40,             /// +
    SUB = 0x41,             /// -
    // L4
    LT = 0x60,              /// <
    LTE = 0x61,             /// <=
    GT = 0x62,              /// >
    GTE = 0x63,             /// >=
    EQ = 0x64,              /// ==
    NEQ = 0x65,             /// !=
    // L5
    AND = 0x80,             /// &&
    // L6
    OR = 0xa0,              /// ||
    // encoding for ')', which is not coded by the scanner, L7 is enough as all operators on that level are left asociative
    // correctly it should be at L8, but that is not possible as only the '$' symbol represents this level
    CBRACKET = 0xc0,        /// )
    // L7
    COMMA = 0xc1,           /// ,
    COND_EXPR_END = 0xc2,   /// end of math expression - signalization for the oRPN
    PARAM_COMMA = 0xc4,     /// comma after a function parameter
    RETURN_END = 0xc5,      /// end of return expression
    // COND_EXPR_END, PARAM_COMMA, RETURN_END are not actual operators, the are generated by the parser in places, 
    // where L7 operators are not pressent (condition statements, function parameters, return statement) 
    ADD_EQ = 0xc6,          /// +=
    MUL_EQ = 0xc7,          /// *=
    DIV_EQ = 0xc8,          /// /=
    SUB_EQ = 0xc9,          /// -=
    EQ_ASSGN = 0xca,        /// =
    EQ_DEF = 0xcb,          /// :=
};  

/* */
enum token_types{
    T_OP = 0,           /// +, -, *, /, >, >=, <, <=, !=, ==, &&, ||, !
    T_IDF = 1,          /// 'some_text'
    T_FUNC = 2,         /// 'some_text'
    T_STRING = 3,       /// "string literal"
    T_KEY = 4,          /// package, if, else, for, return, func
    T_TYPE = 5,         /// int, float, string
    T_EQ = 6,           /// =, +=, -=, *=, /=, :=
    T_OCB = 7,          /// {
    T_CCB = 8,          /// }
    T_OB = 9,           /// (
    T_CB = 10,          /// )
    T_COMMA = 11,       /// ,
    T_NL = 12,          /// new line
    T_SEMI = 13,        /// ;
    T_NUM = 14,         /// number (decimal, integer or boolean) - used by the parser

    // types of tokens generated by the parser and used by the token list, optimalizer and generator
    T_INT = 15,          /// integer number
    T_FLOAT = 16,        /// floating point number
    T_BOOL = 17,         /// boolean value
    T_END,          /// end of the current expression

    //different types of expressions
    T_ASSGN,            /// start of assign expression
    T_MULTI_ASSGN,      /// start of multi assign
    T_ASSGN_END,        /// end of assign expression
    T_MULTI_ASSGN_END,  /// end of multi assign expression
    T_FUNC_DEF,         /// start of function definition
    T_FISRT_FCALL,      /// function call without any assignment
    T_FIRST_FCALL_END,  /// end of void function call
    T_FUNC_CALL,        /// start of function call
    T_FCALL_END,        /// end of function call
    T_PARAM,            /// function parameter
    T_PARAM_END,        /// end of function parameter
    T_IF,               /// start of if header
    T_IF_BODY,          /// start of if body
    T_IF_BODY_END,      /// end of if body
    T_ELSE,             /// start of else header
    T_ELSE_BODY,        /// start of else body
    T_ELSE_BODY_END,    /// end of else body
    T_ELIF,             /// start of elif header
    T_ELIF_BODY,        /// start of elif body
    T_ELIF_BODY_END,    /// end of elif body
    T_FOR1,             /// start of the first part of for header expression
    T_FOR1_EMPTY,       /// empty for1 part of for header
    T_FOR1_END,         /// end of the first part of for cycle header
    T_FOR2,             /// start of the second part of for header expression
    T_FOR3,             /// start of the third part of for header expression
    T_FOR3_EMPTY,       /// empty for3 part of the for header
    T_FOR3_END,         /// end of for3 in for header
    T_FOR_BODY,         /// start of for body
    T_FOR_BODY_END,     /// end of for body
    T_FUNC_BODY,        /// start of function body
    T_FUNC_BODY_END,    /// end of function body
    T_RETURN,           /// start of return statement
    T_RET_NEXT,         /// next return value
    T_RETURN_END,       /// end of return statement
    T_EXPRESSION,       /// start of mathematical expression
    T_NEXT_VAL,         /// next value in a multi assignment
    T_VAR_DEF,          /// new variable definition
    T_JMP_IF_EQ,        /// jump if two following token values equal
    T_JMP_IF_NEQ,       /// jump if two following token values does not equal
    T_JMP_FOR_EQ,       /// jump if two following token values equal in for cycle
    T_JMP_FOR_NEQ,      /// jump if two following token values does not equal in forcycle
    T_REGISTER,         /// generate register
    T_ADDRESS_ASSGN,    /// generate address assign
    T_ADR_ASSGN_END,    /// stop address assign generation
    T_MOV,              /// generate MOVE
    T_SINGLE_VAL_IF,    /// jump if the value is true, do not jump otherwise
    T_SINGLE_VAL_FOR,   /// jump if the value is true, do not jump otherwise in for cycle
    T_VARS_END,         /// end of assigned variables
    T_WRITE_INST,       /// generate WRITE
    T_LEN_INST,         /// generate STRLEN
    T_I2F_INST,         /// generate INT2FLOAT
    T_F2I_INST,         /// generate FLOAT2INT
    T_PUSHS,            /// generate PUSHS
    T_PRECOMPILED,      /// copy precompiled code
    T_VARS_DUMMY,       /// do nothing with the previous variable
    T_EMPTY,            /// padding
    T_I2FS_INST,        /// generate INT2FLOAT
    T_F2IS_INST,        /// generate FLOAT2INT
        
    //build in function tokens
    T_INS,	    /// inputs
    T_INI,	    /// inputi
    T_INF,	    /// inputf
    T_INB,	    /// inputb
    T_I2F,	    /// int2float
    T_F2I,	    /// float2int
    T_PRINT,	/// print
    T_ORD,	    /// ord
    T_CHR,	    /// chr
    T_SUBS,	    /// substr
    T_LEN,	    /// len

    T_PROG_END, /// end of program 
};

enum curly_brackets{
    NO_CB = 0,
    FUNCTION_CB, 
    IF_CB, 
    ELIF_CB, 
    ELSE_CB, 
    FOR_CB,
};

enum ret_types_signature{
    NAMED_S = 1,
    NOT_NAMED_S = 2,
    NOT_SET_S = 3,
};

// see parser_private.h
enum expression_types{
    E_NONE,
    E_ASSGN,
    E_MULTI_ASSGN,
    E_DEF,
    E_MULTI_DEF,
    E_IF,
    E_ELIF,
    E_ELSE,
    E_FOR1,
    E_MULTI_FOR1,
    E_FOR2,
    E_FOR3,
    E_MULTI_FOR3,
    E_RETURN,
    E_PARAM,
    E_FIRST_FUNC,
};

enum function_states{ 
    F_UNDEF = 0, 
    F_DEF,
    F_IN_DEF,
};

enum variable_states
{
    V_UNDEF = 0,
    V_DEF,
    V_VALUE,
};

enum function_return_states
{
    SKIP_SCOPE_FOUND,
	LOOKING, 
    SKIP_SCOPE_LOOKING,
    SKIP_REST_OF_BODY,
    FOUND_DEFINITIVELY,	
};
enum function_return_tokens
{
	IF_START,
    ELIF_START,
    ELSE_START,
    IF_END,
    ELSE_END,
    RETURNERINO,
    FUNCTION_WITH_RETURN,
    FUNCTION_WITHOUT_RETURN,
    FUNCTION_BODY_END,
};

#endif //__ENUMS_H__
